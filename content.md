# Парсер комбинаторы на Kotlin

## Введение

Существуют разные способы реализации синтаксических анализоторов для заданной граматики. 
В статье рассматривается подход, называемый **Комбинаторы синтаксического анализа**, так же можно встретить название **Парсер комбинаторы**.
Когда, я впервые познакомился с этим подходом, он произвел на меня сильное впечатление, 
потому что, без использвоания внешних фреймворков можно легко и быстро реализовать свою библиотеку, 
которая позволяет описывать парсеры в деклатротивном стиле. 
**Парсер комбинаторы** можно использовать для прототипирования или написания легко расширяемого синтаксического анализатора.
В статье мы рассмотрим примеры реализации **Парсер комбинаторов** на языке Kotlin. 
Напишим синтаксические анализаторы для арифмитических выражений и функций вида `"%s = %d".format("2 + 2", 5)`, в которых типы аргументов определяются строкой формата.
А также увидим примеры применения комбинаторов не только для написания парсеров.
Код используемый в статье доступен в [репозитории]().

### Вспомним несколько понятий из теории формальных языков. ### 
**Формальный язык** это множество слов над конечным множеством символов - алфавитом. 
Для того что бы выделить из всего множества слов некоторое его подмножество используют **формальные грамматики**.
Грамматику можно задать набором правил вида: `L -> R`, где `L` - непустая последовательность терминалов и нетерминалов, содержащая хотя бы один нетерминал, 
а `R` - любая последовательность терминалов и нетерминалов. Терминал это объект, состоящий только из символов алфавита, а нетерминал - объект обозначающий какую либо сущность языка.
Рассмотрим пример задания грамматики правильной скобочной последовательности: 
<pre>
S -> (S)S
S -> &epsi;
</pre>
где `(`, `)` - терминальные символы, `S` - нетерминальный символ, &epsi; - представляет пустую строку.

Для классификации грамматик используют иерархию, предложенную Ноамом Хомским.
По иерархии Хомского грамматики делятся на 4 типа, каждый последующий является более ограниченным подмножеством предыдущего и легче поддается анализу:
- тип 0. неограниченные грамматики — возможны любые правила;
- тип 1. контекстно-зависимые грамматики — левая часть может содержать один нетерминал, окруженный «контекстом» - последовательность символов, в том же виде присутствующая в правой части;
- тип 2. контекстно-свободные грамматики — левая часть состоит из одного нетерминала;
- тип 3. регулярные грамматики.

В статье, мы в качестве примеров, будем рассматривать анализаторы, соответствующие только контекстно-свободным(КС) и контекстно-зависимым(КЗ) грамматикам.
К примеру, языки, порождаемые КС-грамматиками это - правильные скобочные последовательнтсти(пример грамматики был выше) или арифметические выражения.
В качестве языков, порождаемых КЗ-грамматиками можно рассмотреть, например, протоколы передачи данных, 
в которых сообщение сосотоит из заголовка, содержащего длину сообщения, а дальше следует само сообщение. Также интересный пример всречается в современных IDE, 
которые умеют подсвечивать ошибки в случае аргументов направильного типа в коде вида:
```kotlin
"%s = %d".format("2 + 2", 5)
```
Для того что бы разобрать КС-грамматику достаточно автомата с магазинной памятью(МП-автомат),
а вот для разбора КЗ-грамматики потребуется линейно-ограниченный автомат, более можщный формализм с точки зрения вычислимости по сравнению с МП-автоматом. 

### Комбинаторы синтаксичсеского анализа ###

Парсер комбинаторы занимают уникальное место в области синтаксичсеского анализа, они позволяют писать выражения, 
повторяющие струкутру грамматических правил, то есть задают удобный DSL для написания парсеров. 

Я познакомился с это концепцией в [статье Еруна Фокера](https://ru.wikibooks.org/wiki/Функциональные_парсеры).
В ней указано, что впервые, такой подход упоминается в книге Вильяма Бурджа "Recursive programming techniques", изданной в 1975 году.  
На текущий момент для разных языков программирования существуют удобные библиотеки для работы с парсер комбинаторами.

Итак, комбинаторы парсеров это конструкторы, которые на основе одних парсеров создают другие, более сложные, например комбинатор альтернативы `Alt(p1, p2)` 
применит к строке сначала парсер `p1` и если разбор завершится с ошибкой, то применит `p2`. Или комбинатор следования `Seq(p1, p2)`, прменяющий последовательно `p1` и `p2`.

## Tип `Parser` и элементарные синтаксические анализаторы.
### `Parser` и `ParseResult` ###
Начнем с определения интерфейса `Parser` и результата работы парсера `ParseResult`.

Запечатанный интерфейс `ParseResult<out A>` представляет успешный или неуспешный результат разбора.
```kotlin
sealed interface ParseResult<out A> {
    data class Fail(val msg: String) : ParseResult<Nothing>
    data class Success<A>(val tail: String, val pos: Int, val result: A) : ParseResult<A>
}
```
Обратите внимание как мы используем `Nothing` для класса `Fail` - это возможно, потому что `Nothing` является наследником любого класса в Kotlin. 

В классе `Fail` аттрибут `msg` это сообщение об ошибке, а в классе `Success` аттрибуты:
 - `tail` - оставшаяся часть строки, которую еще нужно разобрать;
 - `pos` - позиция, указывающая на ту часть строки, которые мы уже разобрали, мы будем использовать эту информацию, для того что бы указать позицию с которой парсер не смог разобрать строку;
 - `result` - результат работы парсера, это может что угодно, например символ типа `Char` или синтаксическое дерево разбора.  

Интерфейс парсера определяется просто:
```kotlin
interface Parser<A> {
    fun parse(str: String): ParseResult<A>
}
```
При реализации комбинаторов часто придется выполнять шаблонное действие, такое что если предыдущий парсер вернул `Fail`, то ничего не делать, а если `Success` то выполнить некоторые действия и вернуть результат.
Поэтом введем вспомогательную функцию `map`:

```kotlin
fun <T, R> ParseResult<T>.map(block: (ParseResult.Success<T>) -> ParseResult<R>) = when (this) {
    is ParseResult.Fail -> this
    is ParseResult.Success -> block(this)
}
```

### Парсер `TakeIf` ###

Теперь все готово что бы написать наш первый парсер, назовем его `TakeIf`. Он будет проверять - соответствует ли первый символ строки заданному предикату.
```kotlin
class TakeIf(private val description: String, private val predicate: (Char) -> Boolean) : Parser<Char> {
    override fun parse(str: String) = when {
        str.isEmpty() -> ParseResult.Fail("Input string is empty")
        !predicate(str.first()) -> ParseResult.Fail("Symbol '${str.first()}' does not satisfy predicate: $description")
        else -> ParseResult.Success(str.drop(1), 1, str.first())
    }
}
```
Думаю код не требует пояснений. 
Дополнительно введем функцию, которая возвращает парсер, проверяющий соответствие первого симовла строки заданному, она нам прегадится в будущем:
```kotlin
fun symbol(c: Char) = TakeIf("equals $c") { it == c }
```

Результат работы парсера:
```kotlin
println(symbol('a').parse("abc")) // output: Success(tail=bc, pos=1, result=a)
println(symbol('b').parse("abc")) // output: Fail(msg=Symbol 'a' does not satisfy predicate: equals b)
```

Можно расширять набор элементарных парсеров и дальше вводя к примеру такие как `number(n)`, `string(str)` и так далее. 
Мы не будем этого делать, так как они нам не понадобятся. Вообще говоря, достаточно только одного элементарного парсера `symbol(c)` для всех задач.
Имея такие простые парсеры можно конструировтаь анализаторы терминальных символов, но как мы видели в правилах грамматики присутствуют и нетерминалы и комбинации терминалов и нетерминалов.
Для построения более мощных анализаторов потребуются комбинаторы.








