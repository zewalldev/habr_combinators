# Парсер комбинаторы на Kotlin

## Введение

Существуют разные способы реализации синтаксических анализоторов для заданной граматики. 
В статье рассматривается подход, называемый **Комбинаторы синтаксического анализа**, так же можно встретить название **Парсер комбинаторы**.
Когда, я впервые познакомился с этим подходом, он произвел на меня сильное впечатление, 
потому что, без использвоания внешних фреймворков можно легко и быстро реализовать свою библиотеку, 
которая позволяет описывать парсеры в деклатротивном стиле. 
**Парсер комбинаторы** можно использовать для прототипирования или написания легко расширяемого синтаксического анализатора.
В статье мы рассмотрим примеры реализации **Парсер комбинаторов** на языке Kotlin. 
Напишим синтаксические анализаторы для арифмитических выражений и функций вида `"%s = %d".format("2 + 2", 5)`, в которых типы аргументов определяются строкой формата.
Код используемый в статье доступен в [репозитории]().

### Вспомним несколько понятий из теории формальных языков.
**Формальный язык** это множество слов над конечным множеством символов - алфавитом. 
Для того что бы выделить из всего множества слов некоторое его подмножество используют **формальные грамматики**.
Грамматику можно задать набором правил вида: `L -> R`, где `L` - непустая последовательность терминалов и нетерминалов, содержащая хотя бы один нетерминал, 
а `R` - любая последовательность терминалов и нетерминалов. Терминал это объект, состоящий только из символов алфавита, а нетерминал - объект обозначающий какую либо сущность языка.
Рассмотрим пример задания грамматики правильной скобочной последовательности: 
<pre>
S -> (S)S
S -> &epsi;
</pre>
где `(`, `)` - терминальные символы, `S` - нетерминальный символ, &epsi; - представляет пустую строку.

Для классификации грамматик используют иерархию, предложенную Ноамом Хомским.
По иерархии Хомского грамматики делятся на 4 типа, каждый последующий является более ограниченным подмножеством предыдущего и легче поддается анализу:
- тип 0. неограниченные грамматики — возможны любые правила;
- тип 1. контекстно-зависимые грамматики — левая часть может содержать один нетерминал, окруженный «контекстом» - последовательность символов, в том же виде присутствующая в правой части;
- тип 2. контекстно-свободные грамматики — левая часть состоит из одного нетерминала;
- тип 3. регулярные грамматики.

В статье, мы в качестве примеров, будем рассматривать анализаторы, соответствующие только контекстно-свободным(КС) и контекстно-зависимым(КЗ) грамматикам.
К примеру, языки, порождаемые КС-грамматиками это - правильные скобочные последовательнтсти(пример грамматики был выше) или арифметические выражения.
В качестве языков, порождаемых КЗ-грамматиками можно рассмотреть, например, протоколы передачи данных, 
в которых сообщение сосотоит из заголовка, содержащего длину сообщения, а дальше следует само сообщение. Также интересный пример всречается в современных IDE, 
которые умеют подсвечивать ошибки в случае аргументов направильного типа в коде вида:
```kotlin
"%s = %d".format("2 + 2", 5)
```
Для того что бы разобрать КС-грамматику достаточно автомата с магазинной памятью(МП-автомат),
а вот для разбора КЗ-грамматики потребуется линейно-ограниченный автомат, более можщный формализм с точки зрения вычислимости по сравнению с МП-автоматом. 

### Комбинаторы синтаксичсеского анализа

Парсер комбинаторы занимают уникальное место в области синтаксичсеского анализа, они позволяют писать выражения, 
повторяющие струкутру грамматических правил, то есть задают удобный DSL для написания парсеров. 

Я познакомился с это концепцией в [статье Еруна Фокера](https://ru.wikibooks.org/wiki/Функциональные_парсеры).
В ней указано, что впервые, такой подход упоминается в книге Вильяма Бурджа "Recursive programming techniques", изданной в 1975 году.  
На текущий момент для разных языков программирования существуют удобные библиотеки для работы с парсер комбинаторами.

Итак, комбинаторы парсеров это конструкторы, которые на основе одних парсеров создают другие, более сложные, например комбинатор альтернативы `Alt(p1, p2)` 
применит к строке сначала парсер `p1` и если разбор завершится с ошибкой, то применит `p2`. Или комбинатор следования `Seq(p1, p2)`, прменяющий последовательно `p1` и `p2`.

## Tип `Parser` и элементарные синтаксические анализаторы.

### `Parser` и `ParseResult`
Начнем с определения интерфейса `Parser` и результата работы парсера `ParseResult`.

Запечатанный интерфейс `ParseResult<out A>` представляет успешный или неуспешный результат разбора.
```kotlin
sealed interface ParseResult<out A> {
    data class Fail(val msg: String) : ParseResult<Nothing>
    data class Success<A>(val tail: String, val result: A) : ParseResult<A>
}
```
Обратите внимание как мы используем `Nothing` для класса `Fail` - это возможно, потому что `Nothing` является наследником любого класса в Kotlin. 

В классе `Fail` аттрибут `msg` это сообщение об ошибке, а в классе `Success` аттрибуты:
 - `tail` - оставшаяся часть строки, которую еще нужно разобрать;
 - `result` - результат работы парсера, это может что угодно, например символ типа `Char` или синтаксическое дерево разбора.  

Интерфейс парсера определяется просто:
```kotlin
interface Parser<A> {
    fun parse(str: String): ParseResult<A>
}
```
При реализации комбинаторов часто придется выполнять шаблонное действие, такое что если предыдущий парсер вернул `Fail`, то ничего не делать, а если `Success` то выполнить некоторые действия и вернуть результат.
Поэтом введем вспомогательную функцию `map`:

```kotlin
fun <T, R> ParseResult<T>.map(block: (ParseResult.Success<T>) -> ParseResult<R>) = when (this) {
    is ParseResult.Fail -> this
    is ParseResult.Success -> block(this)
}
```

### Парсер `TakeIf`

Теперь все готово что бы написать наш первый парсер `TakeIf`. Он будет проверять - соответствует ли первый символ строки заданному предикату.
```kotlin
class TakeIf(private val description: String, private val predicate: (Char) -> Boolean) : Parser<Char> {
    override fun parse(str: String) = when {
        str.isEmpty() -> ParseResult.Fail("Input string is empty")
        !predicate(str.first()) -> ParseResult.Fail("Symbol '${str.first()}' does not satisfy predicate: $description")
        else -> ParseResult.Success(str.drop(1), str.first())
    }
}
```
Думаю код не требует пояснений. 
Дополнительно введем функцию, которая возвращает парсер, проверяющий соответствие первого симовла строки заданному, она нам прегадится в будущем:
```kotlin
fun symbol(c: Char) = TakeIf("equals $c") { it == c }
```

Результат работы парсера:
```kotlin
println(symbol('a').parse("abc")) // output: Success(tail=bc, pos=1, result=a)
println(symbol('b').parse("abc")) // output: Fail(msg=Symbol 'a' does not satisfy predicate: equals b)
```

### Парсер `Return`

Парсер `Return` всегда возращает заданное занчение и он пригодится нам в будущем:
```kotlin
class Return<A>(private val a: A) : Parser<A> {
    override fun parse(str: String) = ParseResult.Success(str, 0, a)
}
```

Можно расширять набор элементарных парсеров и дальше вводя к примеру такие как `number(n)`, `string(str)` и так далее. 
Мы не будем этого делать, так как они нам не понадобятся.
Имея такие простые парсеры можно конструировтаь анализаторы терминальных символов, но как мы видели в правилах грамматики присутствуют и нетерминалы и комбинации терминалов и нетерминалов.
Для построения более мощных анализаторов потребуются комбинаторы.

## Комбинаторы 

### Alt и Seq 

Вспомним, каким образом задаются правила грамматики, например для правильной скобочной последовательности:
<pre>
S -> (S)S
S -> &epsi;
</pre>
Глядя на эти правила становится ясно, что потребуются комбинаторы следования `Seq` и альтернативы `Alt`.
`Seq` это комбинатор типа `Parser<Pair<A, B>>`, который принимает на вход два парсера `pa: Parser<A>`, `pb: Parser<B>` и применяет их последовательно, возвращаея `Pair<A, B>`:
```kotlin
class Seq<A, B>(private val pa: Parser<A>, private val pb: Parser<B>) : Parser<Pair<A, B>> {
    override fun parse(str: String) = pa.parse(str).map { it1 ->
        pb.parse(it1.tail).map { it2 ->
            ParseResult.Success(it2.tail, it1.result to it2.result)
        }
    }
}
```
Комбинатор `Alt` на основе парсеров `p1, p2: Parser<A>` конструирует парсер, возвращающий результат применения `p1`, а если он вернет `Fail`, то результат применения `p2`:
```kotlin
class Alt<A>(private val p1: Parser<A>, private val p2: Parser<A>) : Parser<A> {
    override fun parse(str: String) = when (val r = p1.parse(str)) {
        is ParseResult.Fail -> p2.parse(str)
        is ParseResult.Success -> r
    }
}
```

### Преобразователь парсеров `Mapper` и "ленивость"

Если бы мы сейчас решили реализовать парсер для разбора правильной скобочной последовательности, то написали бы такой код:
```kotlin
val `(` = symbol('(')
val `)` = symbol(')')

fun parens() : Parser<???> = Alt(
    Seq(`(`, Seq(parens(), Seq(`)`, parens()))),
    Return(Unit)
)

fun main() {
    parens().parse("(()())")
}
```
Это нерабочей код, в нем есть две проблемы. Первая это невозможность вычислить тип парсера, возвращаемый функцией `parens()`, 
а вторая - это это рекурсивный вызов функции самой себя. Со второй проблемой легко справиться, добавив "ленивости" нашим парсерам:
```kotlin
fun <A> ref(lazy: () -> Parser<A>) = object : Parser<A> {
    override fun parse(str: String) = lazy().parse(str)
}
```
Для того что бы решить первую проблему, нужно ввести преобразователь типа парсера, который позволит из `Parser<A>` получить `Parser<B>`:
```kotlin
class Mapper<A, B>(private val p: Parser<A>, private val f: (A) -> B) : Parser<B> {
    override fun parse(str: String) = p.parse(str).map { ParseResult.Success(it.tail, f(it.result)) }
}
```
Теперь мы можем написать рабочий код, который превращает правильную скобочную последовательность в дерево разбора:
```kotlin
val `(` = symbol('(')
val `)` = symbol(')')

fun parens(): Parser<Tree> = Alt(
    Mapper(
        Seq(
            `(`,
            Seq(
                ref { parens() },
                Seq(
                    `)`,
                    ref { parens() }
                )
            )
        )
    ) { (_, a) -> Tree.Node(a.first, a.second.second) },
    Return(Tree.Leaf)
)

fun main() {
    println(parens().parse("(()())")) //output: Success(tail=, pos=6, result=Node(left=Node(left=Leaf, right=Node(left=Leaf, right=Leaf)), right=Leaf))
}
```
Подведем промежуточный итог. 
Мы реализовали пару элементарных парсеров `TakeIf` и `Return<A>`, преобразователь `Mapper<A, B>` и пару комбинаторов `Alt<A>`, `Seq<A, B>`.
С таким набором инструметов можно разбирать КС-грамматики, но стоит признать, что код таким образом писать не удобно.
Введем несколько вспомогательных функций.

### Вспомогательные функции `alt`, `seq`, `optional`, `manyOf` и `someOf`

Функция `alt(p: Parser<A>, vararg ps: Parser<A>)` будет принимать на вход набор парсеров, и возвращать комбинатор, который применяет эти парсеры к строке пока результат не будет `Success`.
Реализуем ее с помощью свертки(`fold`)
```kotlin
fun <A> alt(p: Parser<A>, vararg ps: Parser<A>): Parser<A> = ps.fold(p) { x, xs -> Alt(x, xs) }
```
Функция `seq` будет также как и `alt` принимать на вход набор парсеров и последним аргументов функцию преобразования, например, в случае для трех парсеров ее сигнатура будет иметь вид:
```kotlin
seq(p1: Parser<X1>, p2: Parser<X2>, p3: Parser<X3>, f: (X1, X2, X3) -> Y): Parser<Y>
```
Для `seq` не получится сделать универсального решения, так как тип `f` зависит от типов предыдущих аргументов.
Нам потребуется функция, которые преобразуют тип вида `(X1, X2, X3, X4) -> Y` в тип `(Pair<X1, Pair<X2, Pair<X3, X4>>>) -> Y`.
Приведу пример для трех аргументов, а более подробно с кодом можно познакомиться в [репозетории]():
```kotlin
fun <X1, X2, X3, X4, Y> args2tuple(f: (X1, X2, X3, X4) -> Y): (Pair<X1, Pair<X2, Pair<X3, X4>>>) -> Y =
    args2tuple { x1, x2, (x3, x4) -> f(x1, x2, x3, x4) }

fun <X1, X2, X3, Y> seq(p1: Parser<X1>, p2: Parser<X2>, p3: Parser<X3>, f: (X1, X2, X3) -> Y) =
    Mapper(Seq(p1, Seq(p2, p3)), args2tuple(f))
```
Так же нам будут полезны комбинаторы:
- `optional(p: Parser<A>, a: A): Parser<A>` - применяет парcер `p` и в случае неудачи возвращает значение `a`;
- `someOf(p: Parser<A>): Parser<List<A>>` - ожидает что `p` вернет `Success` хотя бы один раз;
- `manyOf(p: Parser<A>): Parser<List<A>>` - пытается применить парсер `p` столько раз, сколько получиться, если не получилось ни разу, то вернет пустой список.

Их реализация:
```kotlin
fun <A> optional(p: Parser<A>, a: A) = alt(p, Return(a))

fun <A> someOf(p: Parser<A>): Parser<List<A>> = seq(p, ref { manyOf(p) }) { x, xs -> listOf(x) + xs }

fun <A> manyOf(p: Parser<A>): Parser<List<A>> = optional(someOf(p), emptyList())
```
Нужно отметить, что приведенная выше реализация функций `someOf` и `manyOf` неоптимальна из-за рекурсивных вызовов, использовать такой код в реальных проектах нужно с осторожностью.

Используя вспомогательные функции, определенные выше парсер `parens()` можно переписать в более удобном виде:
```kotlin
fun parens2(): Parser<Tree> = optional(
    seq(`(`, ref { parens2() }, `)`, ref { parens2() }) { _, left, _, right -> Tree.Node(left, right) },
    Tree.Leaf
)

fun main() {
    println(parens2().parse("(()())")) // output: Success(tail=, result=Node(left=Node(left=Leaf, right=Node(left=Leaf, right=Leaf)), right=Leaf))
}
```
Теперь мы готовы приступить к написанию синтаксического анализатора арифметических выражений. 

### Разбор арифметических выражений
В этом разделе мы опишем парсер, который разбирает и сразу же вычисляет арифметические выражения:
```kotlin
fun exp(): Parser<Double> = ...

println(exp().parse("3+4*(1/(2*3*4)-1/(4*5*6)+1/(6*7*8)-1/(8*9*10)+1/(10*11*12))")) // output: Success(tail=, result=3.1427128427128426)
```
Грамматика арифметических выражений задается следующим образом:
<pre>
op1 -> '+' | '-'
op2 -> '*' | '/'
exp -> exp op1 term | term
term -> term op2 factor | factor
factor -> number | '(' exp ')' | -factor
</pre>
Для того что бы написать анализатор по правилам грамматики нужно каждый терминальный и нетерминальный символы заменить на соответствующий парсер.
Если мы сделаем это для приведенных правил, то получится примерно следующий код:
```kotlin
fun exp() = seq(ref { exp() }, op1(), term()) {...}
```
Если применить парсер `exp` к строке то он будет вызывать сам себя пока не кончится память.
Для того что бы исключить левую рекурсию, нужно правило вида `A -> A a | b` преобразовать к правилам вида:
<pre>
A -> b A' | b
A' -> a A | a
</pre>
Подробнее об алгоритме устранения левой рекурсии можно почитать в [статье](https://neerc.ifmo.ru/wiki/index.php?title=Устранение_левой_рекурсии).
Преобразуем правила в соответствие с этим алгоритмом:
<pre>
op1 -> '+' | '-'
op2 -> '*' | '/'
exp -> term exp1 | term
exp1 -> op1 term exp1 | op1 term
term -> factor term1 | factor
term1 -> op2 factor term1 | op2 factor
factor -> number | '(' exp ')' | -factor
</pre>
Не буду приводить полный код для разбора арифметических выражений, его можно посмотреть в [репозитории](), но хочу обсудить типы промежуточных парсеров `exp1(), term1()`, потому что они могут казаться не совсем обычными.
Ясно что тип `fun factor(): Parser<Double>`, учитывая что `op2` это по сути парсер бинарного оператора имеющий тип `fun op2(): Parser<(Double, Double) -> Double> `, 
тогда получаем, что тип `fun term1(): Parser<(Double) -> Double>`. В коде это выглядит следующим образом:
```kotlin
// term1 -> op2 factor term1 | op2 factor
fun term1(): Parser<(Double) -> Double> = alt(
    seq(op2(), factor(), ref { term1() }) { op, b, t -> { a -> t(op(a, b)) } },
    seq(op2(), factor()) { op, b -> { a -> op(a, b) } }
)
```
Такие же рассуждения можно провести и для `exp1()`.

### Ограничения комбинаторов `Seq` и `Alt`
Вспоминая, что КС-грамматика описывается правилами, левые части которых состоят только из одного нетерминального объекта, то интуитивно понятно, что с помощью 
комбинаторов `seq` и `alt` можно описать анализатор любой КС-грамматики. 
Для КЗ-грамматики, правила которой могут иметь вид `a A b -> a w b`, приведенных выше комбинаторов недостаточно.
Рассмотрим КЗ-язык:
<pre>
{a<sup>n</sup>b<sup>n</sup>c<sup>n</sup>: n &ge; 0}
</pre>
Слова этого языка состоят из трех групп символов одинаковой длины, например `aabbcc`.
Думаю, что если бы мы решили бы сформировать правила грамматики с одним нетерминальным символом слева, то получился бы бесконечный набор правил.
Если хочется узнать как выглядит грамматика этого языка, то можно подсмотреть, например в [википедии](https://ru.wikipedia.org/wiki/Контекстно-зависимая_грамматика#:~:text=Контекстно%20зависимая%20грамматика%20(КЗ%2Dграмматика,окружены%20терминальными%20и%20нетерминальными%20символами.).

Но вот если бы у нас был способ выбора парсера на основе результата предыдущего разбора, то мы смогли бы написать синтаксический анализатор этого языка.

## Комбинатор связывания и анализ КЗ-грамматики
Многие компиляторы и IDE умеют показывать предупреждения если в форматированном выводе, например `printf("%s = %f", "2 + 2", 5)`
порядок типов спецификаторов не соответствует порядку типов аргументов. Грамматика, разбирающая такого вида выражения является контекстно-зависимой, 
так как парсеры, разбирающие аргументы зависят от строки со спецификацией формата вывода.  

### Комбинатор связывания и пример разбора КЗ-грамматики
Приведем комбинатор `Binder`, который принимает на вход парсер `p: Parser<A>` и функцию `bind: (A) -> Parser<B>`, 
и позволяет осуществлять выбор о том какой парсер нужно использовать далее на основе предыдущих результатов:
```kotlin
class Binder<A, B>(private val pa: Parser<A>, private val bind: (A) -> Parser<B>) : Parser<B> {
    override fun parse(str: String) = pa.parse(str).map {
        bind(it.result).parse(it.tail)
    }
}

fun <A, B> Parser<A>.then(bind: (A) -> Parser<B>): Parser<B> = Binder(this, bind)
```

Теперь попробуем применить `Binder` для разбора выражения `printf("%s = %f", "2 + 2", 5)`. 
Я приведу пример парсера, который возвращает `Success<Unit>` если типы аргументов соответствуют спецификатором формата, 
в противном случае `Fail` без дополнительной информации, о том, где именно ошибка.
Всего мы будем рассматривать два спецификатора:
- `%f` - число
- `%s` - строка

Код основного парсера:
```kotlin
fun printf(): Parser<Unit> = seq(
    string("printf"),
    `(`,
    quotedFrmStr().then {
        it.map { spec ->
            when (spec) {
                Spec.STR -> seq(comma(), strType()) { _, _ -> }
                Spec.INT -> seq(comma(), numType()) { _, _ -> }
            }
        }.fold(Return(Unit) as Parser<Unit>) { types, type ->
            seq(types, type) { _, _ -> }
        }
    },
    `)`
) { _, _, _, _ -> }
```
Парсер `quotedFrmStr(): Parser<List<Spec>>` возвращает список спецификаторов в порядке следования, затем этот список отображается в соответствующие парсеры, далее список сворачивается с помощью комбинатора `seq`.
Результат работы:
```kotlin
println(printf().parse("printf(\"%s = %f\",\"2 + 2\",2+2)")) // output: Success(tail=, result=kotlin.Unit)
println(printf().parse("printf(\"%f = %s\",\"2 + 2\",5)")) // output:  Fail(...)
```
Обратите внимание, что в первой строке, во втором аргументе используется арифметическое выражение, которое также нужно еще разобрать и вычислить.
Но из-за однообразия способов комбинирования наших парсеров мы спокойно можем использовать результат из раздела "Анализ арифметических выражений":
```kotlin
fun numType() = seq(exp()) { _ -> }
```
Мы закончили с комбинаторами и давайте подведем некоторый итог.
С использованием комбинаторов `seq` и `alt` мы можем построить синтаксические анализаторы, разбирающие КС-грамматики. 
Преимущество такого подхода в декларативном стиле, и в том что структура этих деклараций повторяет структуру правил грамматики.
Если требуется разобрать КЗ-грамматику, то нужно использовать комбинатор связывания `then`, класс разбираемых грамматик расширяется, но сложность компоновки парсеров увеличивается.

При написании комбинаторов мы не использовали специфику синтаксического разбора, поэтому можно предположить, что подобный подход можно использовать и в других случаях.

## Заключение
В статье мы увидели как с помощью комбинаторов можно строить лексические анализаторы. 
Используя комбинаторы `seq` и `alt` можно построить анализатор КС-грамматики в декларативном стиле, но нельзя построить анализатор КЗ-грамматики.
Такой подход, хоть и ограничивает класс распознаваемых языков, но зато позволяет проанализировать парсер, например вывести его полное описание. 
При добавлении комбинатора связывания `then` такая возможность теряется. 

Использование комбинаторов не ограничивается только парсерами, например похоже подход можно использовать для построения валидаторов.
```kotlin

val item: Map<String, Any>

sealed interface PromoAction {
    data class PromoCode(...): PromoAction
    data class Sale(...): PromoAction
} 

fun extractPromo() = alt(
    seq(extractId(), extractPromoCode()) {id, code -> PromoCode(id, code)}, 
    seq(extractId(), extractSale()) {id, saleValue -> Sale(id, saleValue)}
)

extractPromo().run(item) // output: Success(PromoCode) or Success(Sale)
```

Пример кода выше может проверять корректность данных и конструировать на основе этх данных правильные data-классы. 
Конечно, не сложно будет переписать пример выше и обычным образом, но преимущество кода выше в том, что по `extractPromo()` можно автоматически сгенерировать документацию.

На этом я хочу завершить статью и пожелать всем кода без ошибок! Спасибо за внимание.

